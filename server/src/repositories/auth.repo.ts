import { getRepository } from "typeorm";
import { UserPublic, UserPrivate } from "../models";
import bcrypt from "bcrypt";

export type UserCreatePayload = {
  username: string;
  password: string;
};
export type UserCreateResponse = {
  user: UserPublic;
  accessToken: string;
};

export type UserLoginPayload = {
  username: string;
  password: string;
};
export type UserLoginResponse = {
  user: UserPublic;
  accessToken: string;
};

export async function getUserPrivate(
  userId: string
): Promise<UserPublic | null> {
  const repository = getRepository(UserPublic);

  try {
    const user = await repository.findOne(userId);

    if (user) {
      return user;
    }
  } catch (err) {
    console.log(err);
  }

  return null;
}

export async function createUser(
  payload: UserCreatePayload
): Promise<UserCreateResponse> {
  const userPrivateRepository = getRepository(UserPrivate);
  const userPublicRepository = getRepository(UserPublic);

  const userPrivate = new UserPrivate();
  const userPublic = new UserPublic();

  try {
    const username = payload.username;
    const hashedPassword = await userPrivate.hashPassword(payload.password);

    if (!hashedPassword) {
      throw { code: "hash-failed" };
    }

    const userExists = await userPublicRepository.find({ username });
    if (userExists.length) {
      throw { code: "username-taken" };
    }

    // Save user private info
    const dataPrivate = {
      password: hashedPassword,
    };
    const savedPrivateUser = await userPrivateRepository.save({
      ...userPrivate,
      ...dataPrivate,
    });

    // Save user public info using id generated by private
    const dataPublic = {
      id: savedPrivateUser.id,
      username,
    };
    const savedPublicUser = await userPublicRepository.save({
      ...userPublic,
      ...dataPublic,
    });

    const accessToken = userPrivate.generateAccessToken(savedPrivateUser.id);
    if (!accessToken) throw { code: "token-failed" };

    const userCreateResponse: UserCreateResponse = {
      user: savedPublicUser,
      accessToken,
    };

    return userCreateResponse;
  } catch (err) {
    console.log(err);
    throw err;
  }
}

export async function loginUser(
  payload: UserLoginPayload
): Promise<UserLoginResponse> {
  const userPrivateRepository = getRepository(UserPrivate);
  const userPublicRepository = getRepository(UserPublic);

  const username = payload.username;
  const password = payload.password;

  const userPublic = await userPublicRepository.findOne({ username });
  if (!userPublic) {
    throw { code: "user-not-found" };
  }

  const userPrivate = await userPrivateRepository.findOne(userPublic.id);
  if (!userPrivate) {
    throw { code: "unexpected-error" };
  }

  const userHashedPassword = userPrivate.password;
  const passwordCorrect = await bcrypt.compare(password, userHashedPassword);

  if (!passwordCorrect) throw { code: "password-incorrect" };

  const accessToken = userPrivate.generateAccessToken(userPrivate.id);
  const userLoginResponse: UserLoginResponse = {
    user: userPublic,
    accessToken,
  };

  return userLoginResponse;
}
